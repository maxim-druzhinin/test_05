
Разовьем схему управления памятью, существующую в xv6

Общие моменты:

* Не будем сразу ломать то, что есть. Чтобы ОС продолжала работать, пока мы экспериментируем с новым.

* Некоторые задания являются промежуточным этапом к финальной цели. В полностью выполненной последовательности
заданий они могут в явном виде не присутствовать и перекрыться следующим заданием. Или присутствовать не полностью.
Это нормально. Можно их даже не делать в явном виде, а сразу сделать что-то последующее

Например, можно часто пропустить часть задания 1 и сразу реализовать buddy-аллокатор.

* Все хотим делать быстро. В идеале - за константу. В крайнем случае - за что-то, близкое константе (логарифм от чего-нибудь
не сильно гигантского)

* Помним, что мы работаем в параллельной среде. Если нужно создать лок, никто не запрещает это сделать.

* Сумма стоимостей всех заданий - немного больше, чем 10. Это нормально.

Здесь есть бонусные задания.

Если получаете больше, чем 10, то "лишние" баллы можно добавить к любой домашке, где баллы недобраны.

Ключевой момент - после  ваших изменений не должны падать существующие тесты.

Если падают - ищите баги.




## Задание 1. Создадим новый модуль управления памятью

Стоимость: 1 балл

* Разберитесь, как работает kalloc/kfree

* Cкопируйте файл kalloc.c в `buddy_alloc.c`

* Переименуйте kalloc в `baddy_alloc`, kfree в `buddy_free`

* Сделайте так, чтобы область, из которой выделяет kalloc, поделить надвое,
половину оставить kalloc, другую половину отдать `buddy_alloc`

* Поменяйте make-файл так, чтобы `buddy_alloc.c` использовался в сборке

* Замените где-нибудь вызов kalloc на `buddy_alloc`. Например, в аллокации памяти под `struct trapframe`

* Замените освобождение на `buddy_free`

Если все сделано верно, мы подготовили песочницу для экспериментов.





## Задание 2. Реализуем buddy-аллокатор без склейки братьев

Стоимость: 2 балла

Пришло время поменять реализацию `buddy_alloc` и `buddy_free`.

Минимальная единица выделения/освобождения - страница.

Также можно выделять 2, 4, 8, 16, 32, 64, 128, 256, 512 страниц.

Реализуйте схему buddy-аллокатора.

Есть два варианта хранения метаданных:

* прямо в начале каждого выделенного блока

* в отдельной области памяти

Первый вариант сам по себе неплох, но есть проблема. У нас будет доступно для использования
чуть меньше, чем 4096. А в некоторых местах ядра нам важно выделять именно 4096. Поэтому будем использовать
второй.

Оценим количество страниц, которые мы потенциально собираемся выделять.

Оценим количество метаданных на страницу.

Перемножим и получим количество байтов, которые нужны для всех метаданных.

Где их разместить ? Можно немножно отобрать от области, из которой выделяет `kalloc`. Или глобальный
массив в `buddy_alloc.c` завести. На ваше усмотрение.

Если `buddy_alloc` получает в качестве параметра не степень двойки, он возвращает 0.

Если `buddy_alloc` получает в качестве параметра число страниц, которое он не может выделить, он возвращает 0.

Если случается какая-либо другая ошибка при работе `buddy_alloc`, он возвращает 0.

Если ошибок нет, `buddy_alloc`, возвращает адрес выделенной области памяти.

Если `buddy_free` получает в качестве параметра 0, то паникуем.

Если `buddy_free` получает в качестве параметра адрес, который заведомо не может быть адресом выделенной области памяти, то паникуем.

Возможна ситуация, когда `buddy_free` получает в качестве параметра адрес, который в принципе может быть адресом выделенной
области памяти, но в данной конкретной конфигурации таковым не является. Например, он является частью выделенной области памяти,
начинающейся с другого адреса. Или память по этому адресу вообще не выделялась (хотя, адрес является корректным адресом начала
страницы в правильном диапазоне адресов и потенциально он мог бы быть выделен). Или эта область уже освобождалась и заново
не выделялась ("double free").

В этой ситуации действия зависят от организации данных.

Если ваша организация данных дает возможность быстро понять, что адрес некорректен, то надо проверить и запаниковать,
если действительно некорректен (не является адресом ранее выделенной и еще не освобожденной области).

Если не дает, то ничего не проверяем дополнительно. Получаем неопределенное поведение.

Если же в `buddy_free` передано корректное значение, то освобождаем область.






## Задание 3. Реализуем функцию, описывающую состояние кучи

Стоимость: 2 балла

Работает без параметров. Возвращает структуру с полями:

* total - общий размер памяти под управлением, в страницах

* free - общее количество свободной памяти, в страницах, без учета фрагментации

* `free_by_size` - количество свободных участков по размерам. Массив из 10 элементов.

Если в начале работы у нас 2048 страниц, то это [0, 0, 0, 0, 0, 0, 0, 0, 0, 4].

Если после этого вызвали `buddy_alloc(2)`, то это превратится в [0, 1, 1, 1, 1, 1, 1, 1, 1, 3].





## Задание 4. Добавим склейку братьев

Стоимость: 3 балла

При освобождении научимся склеивать братьев. То есть те блоки, которые в buddy-дереве являются сыновьями одного отца.

В частности, до реализации этого задания после каждого `buddy_alloc` количество в старших позициях `free_by_size`
должно более или менее снижаться, и не расти ни при каких `buddy_free`.

После реализации - удачные вызовы `buddy_free` должны увеличивать значения в старших позициях `free_by_size`.




## Задание 5. Попробуем перейти в ядре на `buddy_alloc`. Упрощенный вариант

Стоимость: 2 балла

Закомментарим реализацию `kalloc`, заменим на вызов `buddy_alloc(1)`

Закомментарим реализацию `kfree`, заменим на вызов `buddy_free(pa)`

Все в целом должно работать. Запуск приложений и т.п..

Если вы хорошо все протестировали во время работы над заданиями 2 и 4, то это задание будет очень легким.

Если не очень хорошо, то, возможно, надо будет потрудиться здесь.


Все последующие задания - бонусные.

## Задание 6. Задействуем захват и освобождение областей длиннее страницы

Стоимость: 3 балла

Разберитесь в работе функций `uvmalloc` и `uvmdealloc`.

(Кажется, в одном из вызовов `uvmdealloc` есть баг в xv6 - не вызывается `kfree`. Страницы выпиливаются из `pagetable`,
но остаются неосвобожденными).

Замените циклический вызов `kalloc` на каждую страницу вызовом `buddy_alloc`.

Если запрошенное количество не равно степени двойки, выделяем ближайшую степень двойки.

Если не прошел маппинг в `uvmalloc`, то мы знаем, что передать в `buddy_free`.

Если же `uvmdealloc` вызывается в `grow_proc`, и мы хотим вызвать `buddy_free` (там, где напрашивается вызов
`kfree`, но его нет в силу бага), то тут возможны разные ситуации.

В идеале, мы должны уметь обрабатывать произвольные ассиметричные движения - за счет реалокаций, копирований памяти и т.п., но
мы упростим задачу.

Будем для каждого процесса хранить стек позитивных вызовов `sbrk`. Для каждого негативного будем смотреть, равен ли модуль его
параметра сумме сохраненных на стеке последних положительных параметров.

Если нет, возвращает код ошибки.

Если да, то освобождаем по очереди все то, что необходимо и корректируем стек.

Что-то в `usertests.c` может начать падать. Но в целом ядро должно работать.

## Задание 7. Реализуем схему slab-аллокатора для `struct trapframe`

Стоимость: 3 балла

Функция `slab_init` - инициализирует slab-аллокатор.

В этой функции можно никакой памяти еще не захватывать. Просто проинициализировать какие-то общие метаданные.

Функция `void* slab_alloc()` - захватывает экземпляр `struct trapframe`. 

Если это первый вызов после `slab_init`, то нужно вызвать `buddy_alloc` и запросить одну страницу.

В этой странице нужно отвести часть памяти под метаданные slab-аллокатора, а остальное - поделить на экземпляры
`struct trapframe`.

Выделить первый объект, пометить это в метаданных, вернуть его адрес.

Если объект не первый, ищем свободные позиции.

Если ни в одной странице свободных позиций нет, запрашиваем у `buddy_alloc` новую страницу, включаем ее схему
slab-распределения.

Функция `void slab_free(void* ptr)` - освобождает `struct trapframe`.

`ptr` обязан быть адресом, который вернул `slab_alloc` и который не был уже освобожден.

Если это не так, паникуем.

Иначе - освобождаем.

Если в результате освобождения объекта на странице не осталось неосвобожденных объектов,
возвращаем страницу (`buddy_free`) - внутри реализации `slab_free`.

Стараемся поплотнее использовать захваченные страницы. Поэтому свободных позиций в нескольких страницах
`slab_alloc` должен использовать ту, в которой меньше всего свободных позиций.

## Задание 8. Реализуем схему slab-аллокатора для других структур

Стоимость: 3 балла

Разберитесь, какие структуры динамически захватываются в ядре.

Заведите enum, перечисляющий их.

Этот `enum` передается параметром в `slab_alloc`. И там он учитывается, чтобы понять, из какого именно пула нужно выделять
объект.

В `slab_free` не надо передавать enum. По адресу можно все понять.

Меняем все вызовы `kalloc`/`buddy_alloc`, где захватывается память под маленькие структуры, на `slab_alloc`.

Парные им `kfree`/`buddy_free` меняем на `slab_free`. Все должно работать.

## Задание 9. Выпилим `kalloc`/`kfree`

Стоимость: 1 балл

Последний штрих. Выпиливаем `kalloc`/`kfree` окончательно.

Память под выделение передаем в `buddy_alloc`.

Запускаем, проверяем, что все работает.
